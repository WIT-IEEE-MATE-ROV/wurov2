<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PCA API documentation</title>
<meta name="description" content="Python code for contolling the PCA9685" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PCA</code></h1>
</header>
<section id="section-intro">
<p>Python code for contolling the PCA9685</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;

Python code for contolling the PCA9685

&#34;&#34;&#34;

import time
from smbus import SMBus
from typing import Tuple
# regster num
PCA_REG_PRE_SCALE = 0xFE
PCA_REG_MODE_1 = 0x00

# map for mode 1
PCA_M1_RESTART = 1 &lt;&lt; 7
PCA_M1_EXTCLK = 1 &lt;&lt; 6
PCA_M1_AUTO_INC = 1 &lt;&lt; 5
PCA_M1_SLEEP = 1 &lt;&lt; 4
PCA_CTRL_REG_OFFSET = 0x06


class PCA9685():
    &#39;&#39;&#39;Python Class to controll a PCA9685 over an I2C bus.
        
        Allows for more fine tune control of each PWM signal coming from one of 16 channels.
   
        Referenced this documentation -&gt; https://cdn-shop.adafruit.com/datasheets/PCA9685.pdf
        
        This is a good reference if you need to see what each register for the PCA dose.

    &#39;&#39;&#39;
    
    def __init__(self, i2c_address:int, frequency_hz:float, measured_frequency = None):

        &#39;&#39;&#39;
        Parameters
        ----------

        i2c_address : int
            The unique address of the PCA9585 (default is 0x40)

        frequency_hz : int
            output frequenct of the PWM signal 

        measured_frequency : float
            measured frequency of PCAs signals to adjust for accuracy
        
        &#39;&#39;&#39;

        self.i2c_address = i2c_address
        self.__i2c_bus = SMBus(1)
        self.osc_frequency_Mhz = 25 

        if measured_frequency is not None:
            self.__measured_frequency = measured_frequency
        else:
            self.__measured_frequency = frequency_hz
        
        self.__frequency_hz = frequency_hz


    # TODO - find better way to close i2c bus 
    # def __enter__(self):
    #     &#34;&#34;&#34;Enter handler.&#34;&#34;&#34;
    #     return self

    # def __exit__(self, exc_type, exc_val, exc_tb):
    #     &#34;&#34;&#34;Exit handler.&#34;&#34;&#34;
    #     self.close()

    # def __del__(self):
    #     self.close()


    def  get_bus(self):
        &#39;&#39;&#39;Returns the I2C bus address&#39;&#39;&#39;
        return self.__i2c_bus


    def stop(self):
        &#39;&#39;&#39;Closes the I2C connection
        &#39;&#39;&#39;
        self.__i2c_bus.close()


    def set_measured_frequency(self, measured_frequency:float):
        &#39;&#39;&#39;Updates the measured frequency of the output PWM signals genrated by PCA
        
        Parameters
        ----------
        
        measured_frequency : float
            measured frequency of PCAs signals to adjust for accuracy

        &#39;&#39;&#39;
        self.__measured_frequency = measured_frequency


    def restart(self):
        &#39;&#39;&#39;
        Restarts all the previously active PWM channels
            
        sets the RESTART bit (MODE1 bit 7) to logic 1 at end of PWM refresh cycle
        The contents of each PWM register are held valid when the clock is off.
        
        &#39;&#39;&#39;
        mode_1 = self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_MODE_1)
        mode_1 |= PCA_M1_RESTART
        self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)

    
    def software_reset(self):
        &#39;&#39;&#39;
        Allows for the PCA to be reset to the inital &#39;power up state&#39; without turning the PCA on and off
        &#39;&#39;&#39;
        self.__i2c_bus.write_byte(0x00, 6)  


    def get_mode_1(self):
        &#39;&#39;&#39;
        Returns access to Mode1 register
        &#39;&#39;&#39;
        return self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_MODE_1)
        
    
    def get_prescale(self):
        &#39;&#39;&#39;
        Returns the frequency at which the PCA outputs modulate 

        The max PWM frequency is 1526Hz
        The min PWM frequency is 24Hz

        &#39;&#39;&#39;

       
        return self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_PRE_SCALE)


    def set_prescale(self, pwm_freq_hz: float):
        &#39;&#39;&#39;Sets the frequency of the output PWM signals

            The max PWM frequency is 1526Hz
            The min PWM frequency is 24Hz

        &#39;&#39;&#39;
        # TODO - check if PCAs frequency is not out of range
        # TODO - what is the difrence between pwm_freq_hz and self.__frequency_hz  
        if pwm_freq_hz &gt;= 1500.0:
            raise ValueError(f&#34;[ERROR] The frequency of the PCA is too high. Frequency of {pwm_freq_hz} exceeds 1500Hz&#34;)
        
        if pwm_freq_hz &lt;= 24.0:
            raise ValueError(f&#34;[ERROR] The frequency of the PCA is too low. Frequency of {pwm_freq_hz} sub exceeds 24Hz&#34;)

        mode_1 = self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_MODE_1)
        sleep_state = mode_1 &amp; PCA_M1_SLEEP
        if not sleep_state:
            mode_1 |= PCA_M1_SLEEP
            self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)

        prescale_val = round((self.osc_frequency_Mhz * 1000000.0) / (4096.0 * pwm_freq_hz)) -1 
        print(&#34;prescale_val: &#34;, prescale_val)   
        self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_PRE_SCALE, prescale_val)
        
        if not sleep_state:
            mode_1 &amp;= ~PCA_M1_SLEEP
            self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)


    def start(self):
        &#39;&#39;&#39;
        &#39;&#39;&#39;
        self.restart()
        time.sleep(0.01)  

        mode_1 = PCA_M1_AUTO_INC | 1
        self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)
        self.set_prescale(100)


    def set_sleep(self, sleep_on:bool = True):
        &#39;&#39;&#39;
        Puts the PCA into low power mode by turning off its oscillator
        NOTE: outputs cannot be turned on or off

        Parameters
        ----------

            sleep_on : bool
                Sets the sleep state on or 
            
                True -&gt; on
                False -&gt; off

        &#39;&#39;&#39;
        mode_1 = self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_MODE_1)
        sleep_state = mode_1 &amp; PCA_M1_SLEEP
        print(&#34;Sleep State: &#34;, sleep_state)
        if sleep_on and not sleep_state:
            mode_1 |= PCA_M1_SLEEP
            self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)
        elif not sleep_on and sleep_state:
            mode_1 &amp;= ~PCA_M1_SLEEP
            self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)


    def use_extclk(self):
        &#39;&#39;&#39;
        Allows for the use of an external clock on the PCA.   
        This function will put the PCA to sleep to allow for external clocks to be used.

        Inorder to rest the PCA to the default clock the PCA needs to be software_reset().
        If this doesn&#39;t work try power cycling the PCA.

        &#39;&#39;&#39;
        mode_1 = self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_MODE_1)
        extclk_state = mode_1 &amp; PCA_M1_EXTCLK
        if not extclk_state:
            sleep_state = mode_1 &amp; PCA_M1_SLEEP
            if not sleep_state:
                mode_1 |= PCA_M1_SLEEP
                self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)
            mode_1 |= PCA_M1_EXTCLK
            self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)
            if not sleep_state:
                mode_1 &amp;= ~PCA_M1_SLEEP
                self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)


    def set_counts(self, control_num:int, on_counts:int, off_counts:int):
        &#39;&#39;&#39;
        
        &#39;&#39;&#39;
        ctrl_reg = (control_num * 4) + 6
        ctrl_data = [0]*4

        ctrl_data[0] = on_counts &amp; 0xFF
        ctrl_data[1] = (on_counts &gt;&gt; 8) &amp; 0x0F 
        ctrl_data[2] = off_counts &amp; 0xFF
        ctrl_data[3] = (off_counts &gt;&gt; 8) &amp; 0x0F 

        self.__i2c_bus.write_i2c_block_data(self.i2c_address, ctrl_reg, ctrl_data)


    def get_counts(self, control_num) -&gt; Tuple[int, int]:
        ctrl_reg = (control_num * 4) + 6
        ctrl_data = self.__i2c_bus.read_i2c_block_data(self.i2c_address, ctrl_reg, 4)
        on_counts = ctrl_data[0] + ((ctrl_data[1] &amp; 0xFF) &lt;&lt; 8 )
        off_counts = ctrl_data[2] + ((ctrl_data[3] &amp; 0xFF) &lt;&lt; 8 )

        return (on_counts, off_counts)


    def set_duty_cycle(self, control_num:int, duty_cycle:float):

        pwm_period_us = (1.0 / self.__measured_frequency) * 1_000_000.0
        us_on = (((duty_cycle + 1.0) / 2.0) * 800.0) +1100.0
        us_on_ratio = us_on / pwm_period_us

        off_counts = round(us_on_ratio * 4096.0)
        on_counts = 0

        self.set_counts(control_num, on_counts, off_counts)


    def set_us(self, control_num:int, us:int):
        pwm_period_us = (1.0 / self.__measured_frequency) * 1_000_000.0
        us_on_ratio = us / pwm_period_us

        off_counts = round(us_on_ratio * 4096.0)
        on_counts = 0

        self.set_counts(control_num, on_counts, off_counts)



    def set_duty_cycles(self, start_ctrl:int, duty_cycles):
        end_ctrl = len(duty_cycles) + start_ctrl
        if end_ctrl &gt; 15:
            raise IndexError(f&#34;There only 16 channels on the PCA. Attempted to access channel {end_ctrl}&#34;)

        print(&#39;end_ctrl: &#39;, end_ctrl)
        
        ctrl_len = end_ctrl - start_ctrl
        pwm_period_us = (1.0 / self.__measured_frequency) * 1_000_000.0
        ctrl_data = [0] * (ctrl_len * 4)
        

        for i in range(ctrl_len):
            us_on = (((duty_cycles[i] + 1.0) / 2.0) * 800.0) +1100.0
            us_on_ratio = us_on / pwm_period_us
            off_counts = round(us_on_ratio * 4096.0)
            on_counts = 0
            ctrl_reg = i * 4

            ctrl_data[ctrl_reg] = on_counts &amp; 0xFF
            ctrl_data[ctrl_reg + 1] = (on_counts &gt;&gt; 8) &amp; 0x0F 
            ctrl_data[ctrl_reg + 2] = off_counts &amp; 0xFF
            ctrl_data[ctrl_reg + 3] = (off_counts &gt;&gt; 8) &amp; 0x0F 

        
        print(ctrl_data)

        start_reg = start_ctrl * 4 + 6
        end_reg = end_ctrl * 4 + 6

        reg_length = end_reg - start_reg
        print(&#39;reg_length: &#39;, reg_length)
        
        if end_reg &gt; 69:
            raise OverflowError(&#34;[ERROR] PCA9685 only has 16 control slots&#34;)

        print(&#34;Ctrl data 1: &#34;, ctrl_data[0:32])
        self.__i2c_bus.write_i2c_block_data(self.i2c_address, start_reg, ctrl_data[0:32])
        print(&#39;Start reg: &#39;, start_reg)
        if reg_length &gt; 32:
            ctrl_data_2 = ctrl_data[32:64]
            print(&#34;Ctrl data 2: &#34;, ctrl_data_2)
            ctrl_data_2_start = start_reg + 32
            print(&#39;Ctrl data 2 start: &#39;, ctrl_data_2_start)
            self.__i2c_bus.write_i2c_block_data(self.i2c_address, ctrl_data_2_start, ctrl_data_2)
        
            

if __name__ == &#34;__main__&#34;:

    p = PCA9685(0x42, 100, 103.7)
    p.software_reset()
    p.start()
    p.set_sleep(False)

    p.set_duty_cycles(0, [1]*10)

    print(p.get_counts(0))

    print(p.get_bus().read_i2c_block_data(0x40, 0x00, 4))
    p.stop()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PCA.PCA9685"><code class="flex name class">
<span>class <span class="ident">PCA9685</span></span>
<span>(</span><span>i2c_address: int, frequency_hz: float, measured_frequency=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Python Class to controll a PCA9685 over an I2C bus.</p>
<p>Allows for more fine tune control of each PWM signal coming from one of 16 channels.</p>
<p>Referenced this documentation -&gt; <a href="https://cdn-shop.adafruit.com/datasheets/PCA9685.pdf">https://cdn-shop.adafruit.com/datasheets/PCA9685.pdf</a></p>
<p>This is a good reference if you need to see what each register for the PCA dose.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i2c_address</code></strong> :&ensp;<code>int</code></dt>
<dd>The unique address of the PCA9585 (default is 0x40)</dd>
<dt><strong><code>frequency_hz</code></strong> :&ensp;<code>int</code></dt>
<dd>output frequenct of the PWM signal</dd>
<dt><strong><code>measured_frequency</code></strong> :&ensp;<code>float</code></dt>
<dd>measured frequency of PCAs signals to adjust for accuracy</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PCA9685():
    &#39;&#39;&#39;Python Class to controll a PCA9685 over an I2C bus.
        
        Allows for more fine tune control of each PWM signal coming from one of 16 channels.
   
        Referenced this documentation -&gt; https://cdn-shop.adafruit.com/datasheets/PCA9685.pdf
        
        This is a good reference if you need to see what each register for the PCA dose.

    &#39;&#39;&#39;
    
    def __init__(self, i2c_address:int, frequency_hz:float, measured_frequency = None):

        &#39;&#39;&#39;
        Parameters
        ----------

        i2c_address : int
            The unique address of the PCA9585 (default is 0x40)

        frequency_hz : int
            output frequenct of the PWM signal 

        measured_frequency : float
            measured frequency of PCAs signals to adjust for accuracy
        
        &#39;&#39;&#39;

        self.i2c_address = i2c_address
        self.__i2c_bus = SMBus(1)
        self.osc_frequency_Mhz = 25 

        if measured_frequency is not None:
            self.__measured_frequency = measured_frequency
        else:
            self.__measured_frequency = frequency_hz
        
        self.__frequency_hz = frequency_hz


    # TODO - find better way to close i2c bus 
    # def __enter__(self):
    #     &#34;&#34;&#34;Enter handler.&#34;&#34;&#34;
    #     return self

    # def __exit__(self, exc_type, exc_val, exc_tb):
    #     &#34;&#34;&#34;Exit handler.&#34;&#34;&#34;
    #     self.close()

    # def __del__(self):
    #     self.close()


    def  get_bus(self):
        &#39;&#39;&#39;Returns the I2C bus address&#39;&#39;&#39;
        return self.__i2c_bus


    def stop(self):
        &#39;&#39;&#39;Closes the I2C connection
        &#39;&#39;&#39;
        self.__i2c_bus.close()


    def set_measured_frequency(self, measured_frequency:float):
        &#39;&#39;&#39;Updates the measured frequency of the output PWM signals genrated by PCA
        
        Parameters
        ----------
        
        measured_frequency : float
            measured frequency of PCAs signals to adjust for accuracy

        &#39;&#39;&#39;
        self.__measured_frequency = measured_frequency


    def restart(self):
        &#39;&#39;&#39;
        Restarts all the previously active PWM channels
            
        sets the RESTART bit (MODE1 bit 7) to logic 1 at end of PWM refresh cycle
        The contents of each PWM register are held valid when the clock is off.
        
        &#39;&#39;&#39;
        mode_1 = self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_MODE_1)
        mode_1 |= PCA_M1_RESTART
        self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)

    
    def software_reset(self):
        &#39;&#39;&#39;
        Allows for the PCA to be reset to the inital &#39;power up state&#39; without turning the PCA on and off
        &#39;&#39;&#39;
        self.__i2c_bus.write_byte(0x00, 6)  


    def get_mode_1(self):
        &#39;&#39;&#39;
        Returns access to Mode1 register
        &#39;&#39;&#39;
        return self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_MODE_1)
        
    
    def get_prescale(self):
        &#39;&#39;&#39;
        Returns the frequency at which the PCA outputs modulate 

        The max PWM frequency is 1526Hz
        The min PWM frequency is 24Hz

        &#39;&#39;&#39;

       
        return self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_PRE_SCALE)


    def set_prescale(self, pwm_freq_hz: float):
        &#39;&#39;&#39;Sets the frequency of the output PWM signals

            The max PWM frequency is 1526Hz
            The min PWM frequency is 24Hz

        &#39;&#39;&#39;
        # TODO - check if PCAs frequency is not out of range
        # TODO - what is the difrence between pwm_freq_hz and self.__frequency_hz  
        if pwm_freq_hz &gt;= 1500.0:
            raise ValueError(f&#34;[ERROR] The frequency of the PCA is too high. Frequency of {pwm_freq_hz} exceeds 1500Hz&#34;)
        
        if pwm_freq_hz &lt;= 24.0:
            raise ValueError(f&#34;[ERROR] The frequency of the PCA is too low. Frequency of {pwm_freq_hz} sub exceeds 24Hz&#34;)

        mode_1 = self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_MODE_1)
        sleep_state = mode_1 &amp; PCA_M1_SLEEP
        if not sleep_state:
            mode_1 |= PCA_M1_SLEEP
            self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)

        prescale_val = round((self.osc_frequency_Mhz * 1000000.0) / (4096.0 * pwm_freq_hz)) -1 
        print(&#34;prescale_val: &#34;, prescale_val)   
        self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_PRE_SCALE, prescale_val)
        
        if not sleep_state:
            mode_1 &amp;= ~PCA_M1_SLEEP
            self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)


    def start(self):
        &#39;&#39;&#39;
        &#39;&#39;&#39;
        self.restart()
        time.sleep(0.01)  

        mode_1 = PCA_M1_AUTO_INC | 1
        self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)
        self.set_prescale(100)


    def set_sleep(self, sleep_on:bool = True):
        &#39;&#39;&#39;
        Puts the PCA into low power mode by turning off its oscillator
        NOTE: outputs cannot be turned on or off

        Parameters
        ----------

            sleep_on : bool
                Sets the sleep state on or 
            
                True -&gt; on
                False -&gt; off

        &#39;&#39;&#39;
        mode_1 = self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_MODE_1)
        sleep_state = mode_1 &amp; PCA_M1_SLEEP
        print(&#34;Sleep State: &#34;, sleep_state)
        if sleep_on and not sleep_state:
            mode_1 |= PCA_M1_SLEEP
            self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)
        elif not sleep_on and sleep_state:
            mode_1 &amp;= ~PCA_M1_SLEEP
            self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)


    def use_extclk(self):
        &#39;&#39;&#39;
        Allows for the use of an external clock on the PCA.   
        This function will put the PCA to sleep to allow for external clocks to be used.

        Inorder to rest the PCA to the default clock the PCA needs to be software_reset().
        If this doesn&#39;t work try power cycling the PCA.

        &#39;&#39;&#39;
        mode_1 = self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_MODE_1)
        extclk_state = mode_1 &amp; PCA_M1_EXTCLK
        if not extclk_state:
            sleep_state = mode_1 &amp; PCA_M1_SLEEP
            if not sleep_state:
                mode_1 |= PCA_M1_SLEEP
                self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)
            mode_1 |= PCA_M1_EXTCLK
            self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)
            if not sleep_state:
                mode_1 &amp;= ~PCA_M1_SLEEP
                self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)


    def set_counts(self, control_num:int, on_counts:int, off_counts:int):
        &#39;&#39;&#39;
        
        &#39;&#39;&#39;
        ctrl_reg = (control_num * 4) + 6
        ctrl_data = [0]*4

        ctrl_data[0] = on_counts &amp; 0xFF
        ctrl_data[1] = (on_counts &gt;&gt; 8) &amp; 0x0F 
        ctrl_data[2] = off_counts &amp; 0xFF
        ctrl_data[3] = (off_counts &gt;&gt; 8) &amp; 0x0F 

        self.__i2c_bus.write_i2c_block_data(self.i2c_address, ctrl_reg, ctrl_data)


    def get_counts(self, control_num) -&gt; Tuple[int, int]:
        ctrl_reg = (control_num * 4) + 6
        ctrl_data = self.__i2c_bus.read_i2c_block_data(self.i2c_address, ctrl_reg, 4)
        on_counts = ctrl_data[0] + ((ctrl_data[1] &amp; 0xFF) &lt;&lt; 8 )
        off_counts = ctrl_data[2] + ((ctrl_data[3] &amp; 0xFF) &lt;&lt; 8 )

        return (on_counts, off_counts)


    def set_duty_cycle(self, control_num:int, duty_cycle:float):

        pwm_period_us = (1.0 / self.__measured_frequency) * 1_000_000.0
        us_on = (((duty_cycle + 1.0) / 2.0) * 800.0) +1100.0
        us_on_ratio = us_on / pwm_period_us

        off_counts = round(us_on_ratio * 4096.0)
        on_counts = 0

        self.set_counts(control_num, on_counts, off_counts)


    def set_us(self, control_num:int, us:int):
        pwm_period_us = (1.0 / self.__measured_frequency) * 1_000_000.0
        us_on_ratio = us / pwm_period_us

        off_counts = round(us_on_ratio * 4096.0)
        on_counts = 0

        self.set_counts(control_num, on_counts, off_counts)



    def set_duty_cycles(self, start_ctrl:int, duty_cycles):
        end_ctrl = len(duty_cycles) + start_ctrl
        if end_ctrl &gt; 15:
            raise IndexError(f&#34;There only 16 channels on the PCA. Attempted to access channel {end_ctrl}&#34;)

        print(&#39;end_ctrl: &#39;, end_ctrl)
        
        ctrl_len = end_ctrl - start_ctrl
        pwm_period_us = (1.0 / self.__measured_frequency) * 1_000_000.0
        ctrl_data = [0] * (ctrl_len * 4)
        

        for i in range(ctrl_len):
            us_on = (((duty_cycles[i] + 1.0) / 2.0) * 800.0) +1100.0
            us_on_ratio = us_on / pwm_period_us
            off_counts = round(us_on_ratio * 4096.0)
            on_counts = 0
            ctrl_reg = i * 4

            ctrl_data[ctrl_reg] = on_counts &amp; 0xFF
            ctrl_data[ctrl_reg + 1] = (on_counts &gt;&gt; 8) &amp; 0x0F 
            ctrl_data[ctrl_reg + 2] = off_counts &amp; 0xFF
            ctrl_data[ctrl_reg + 3] = (off_counts &gt;&gt; 8) &amp; 0x0F 

        
        print(ctrl_data)

        start_reg = start_ctrl * 4 + 6
        end_reg = end_ctrl * 4 + 6

        reg_length = end_reg - start_reg
        print(&#39;reg_length: &#39;, reg_length)
        
        if end_reg &gt; 69:
            raise OverflowError(&#34;[ERROR] PCA9685 only has 16 control slots&#34;)

        print(&#34;Ctrl data 1: &#34;, ctrl_data[0:32])
        self.__i2c_bus.write_i2c_block_data(self.i2c_address, start_reg, ctrl_data[0:32])
        print(&#39;Start reg: &#39;, start_reg)
        if reg_length &gt; 32:
            ctrl_data_2 = ctrl_data[32:64]
            print(&#34;Ctrl data 2: &#34;, ctrl_data_2)
            ctrl_data_2_start = start_reg + 32
            print(&#39;Ctrl data 2 start: &#39;, ctrl_data_2_start)
            self.__i2c_bus.write_i2c_block_data(self.i2c_address, ctrl_data_2_start, ctrl_data_2)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="PCA.PCA9685.get_bus"><code class="name flex">
<span>def <span class="ident">get_bus</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the I2C bus address</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def  get_bus(self):
    &#39;&#39;&#39;Returns the I2C bus address&#39;&#39;&#39;
    return self.__i2c_bus</code></pre>
</details>
</dd>
<dt id="PCA.PCA9685.get_counts"><code class="name flex">
<span>def <span class="ident">get_counts</span></span>(<span>self, control_num) ‑> Tuple[int, int]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_counts(self, control_num) -&gt; Tuple[int, int]:
    ctrl_reg = (control_num * 4) + 6
    ctrl_data = self.__i2c_bus.read_i2c_block_data(self.i2c_address, ctrl_reg, 4)
    on_counts = ctrl_data[0] + ((ctrl_data[1] &amp; 0xFF) &lt;&lt; 8 )
    off_counts = ctrl_data[2] + ((ctrl_data[3] &amp; 0xFF) &lt;&lt; 8 )

    return (on_counts, off_counts)</code></pre>
</details>
</dd>
<dt id="PCA.PCA9685.get_mode_1"><code class="name flex">
<span>def <span class="ident">get_mode_1</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns access to Mode1 register</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mode_1(self):
    &#39;&#39;&#39;
    Returns access to Mode1 register
    &#39;&#39;&#39;
    return self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_MODE_1)</code></pre>
</details>
</dd>
<dt id="PCA.PCA9685.get_prescale"><code class="name flex">
<span>def <span class="ident">get_prescale</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the frequency at which the PCA outputs modulate </p>
<p>The max PWM frequency is 1526Hz
The min PWM frequency is 24Hz</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_prescale(self):
    &#39;&#39;&#39;
    Returns the frequency at which the PCA outputs modulate 

    The max PWM frequency is 1526Hz
    The min PWM frequency is 24Hz

    &#39;&#39;&#39;

   
    return self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_PRE_SCALE)</code></pre>
</details>
</dd>
<dt id="PCA.PCA9685.restart"><code class="name flex">
<span>def <span class="ident">restart</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Restarts all the previously active PWM channels</p>
<p>sets the RESTART bit (MODE1 bit 7) to logic 1 at end of PWM refresh cycle
The contents of each PWM register are held valid when the clock is off.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restart(self):
    &#39;&#39;&#39;
    Restarts all the previously active PWM channels
        
    sets the RESTART bit (MODE1 bit 7) to logic 1 at end of PWM refresh cycle
    The contents of each PWM register are held valid when the clock is off.
    
    &#39;&#39;&#39;
    mode_1 = self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_MODE_1)
    mode_1 |= PCA_M1_RESTART
    self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)</code></pre>
</details>
</dd>
<dt id="PCA.PCA9685.set_counts"><code class="name flex">
<span>def <span class="ident">set_counts</span></span>(<span>self, control_num: int, on_counts: int, off_counts: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_counts(self, control_num:int, on_counts:int, off_counts:int):
    &#39;&#39;&#39;
    
    &#39;&#39;&#39;
    ctrl_reg = (control_num * 4) + 6
    ctrl_data = [0]*4

    ctrl_data[0] = on_counts &amp; 0xFF
    ctrl_data[1] = (on_counts &gt;&gt; 8) &amp; 0x0F 
    ctrl_data[2] = off_counts &amp; 0xFF
    ctrl_data[3] = (off_counts &gt;&gt; 8) &amp; 0x0F 

    self.__i2c_bus.write_i2c_block_data(self.i2c_address, ctrl_reg, ctrl_data)</code></pre>
</details>
</dd>
<dt id="PCA.PCA9685.set_duty_cycle"><code class="name flex">
<span>def <span class="ident">set_duty_cycle</span></span>(<span>self, control_num: int, duty_cycle: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_duty_cycle(self, control_num:int, duty_cycle:float):

    pwm_period_us = (1.0 / self.__measured_frequency) * 1_000_000.0
    us_on = (((duty_cycle + 1.0) / 2.0) * 800.0) +1100.0
    us_on_ratio = us_on / pwm_period_us

    off_counts = round(us_on_ratio * 4096.0)
    on_counts = 0

    self.set_counts(control_num, on_counts, off_counts)</code></pre>
</details>
</dd>
<dt id="PCA.PCA9685.set_duty_cycles"><code class="name flex">
<span>def <span class="ident">set_duty_cycles</span></span>(<span>self, start_ctrl: int, duty_cycles)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_duty_cycles(self, start_ctrl:int, duty_cycles):
    end_ctrl = len(duty_cycles) + start_ctrl
    if end_ctrl &gt; 15:
        raise IndexError(f&#34;There only 16 channels on the PCA. Attempted to access channel {end_ctrl}&#34;)

    print(&#39;end_ctrl: &#39;, end_ctrl)
    
    ctrl_len = end_ctrl - start_ctrl
    pwm_period_us = (1.0 / self.__measured_frequency) * 1_000_000.0
    ctrl_data = [0] * (ctrl_len * 4)
    

    for i in range(ctrl_len):
        us_on = (((duty_cycles[i] + 1.0) / 2.0) * 800.0) +1100.0
        us_on_ratio = us_on / pwm_period_us
        off_counts = round(us_on_ratio * 4096.0)
        on_counts = 0
        ctrl_reg = i * 4

        ctrl_data[ctrl_reg] = on_counts &amp; 0xFF
        ctrl_data[ctrl_reg + 1] = (on_counts &gt;&gt; 8) &amp; 0x0F 
        ctrl_data[ctrl_reg + 2] = off_counts &amp; 0xFF
        ctrl_data[ctrl_reg + 3] = (off_counts &gt;&gt; 8) &amp; 0x0F 

    
    print(ctrl_data)

    start_reg = start_ctrl * 4 + 6
    end_reg = end_ctrl * 4 + 6

    reg_length = end_reg - start_reg
    print(&#39;reg_length: &#39;, reg_length)
    
    if end_reg &gt; 69:
        raise OverflowError(&#34;[ERROR] PCA9685 only has 16 control slots&#34;)

    print(&#34;Ctrl data 1: &#34;, ctrl_data[0:32])
    self.__i2c_bus.write_i2c_block_data(self.i2c_address, start_reg, ctrl_data[0:32])
    print(&#39;Start reg: &#39;, start_reg)
    if reg_length &gt; 32:
        ctrl_data_2 = ctrl_data[32:64]
        print(&#34;Ctrl data 2: &#34;, ctrl_data_2)
        ctrl_data_2_start = start_reg + 32
        print(&#39;Ctrl data 2 start: &#39;, ctrl_data_2_start)
        self.__i2c_bus.write_i2c_block_data(self.i2c_address, ctrl_data_2_start, ctrl_data_2)</code></pre>
</details>
</dd>
<dt id="PCA.PCA9685.set_measured_frequency"><code class="name flex">
<span>def <span class="ident">set_measured_frequency</span></span>(<span>self, measured_frequency: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the measured frequency of the output PWM signals genrated by PCA</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>measured_frequency</code></strong> :&ensp;<code>float</code></dt>
<dd>measured frequency of PCAs signals to adjust for accuracy</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_measured_frequency(self, measured_frequency:float):
    &#39;&#39;&#39;Updates the measured frequency of the output PWM signals genrated by PCA
    
    Parameters
    ----------
    
    measured_frequency : float
        measured frequency of PCAs signals to adjust for accuracy

    &#39;&#39;&#39;
    self.__measured_frequency = measured_frequency</code></pre>
</details>
</dd>
<dt id="PCA.PCA9685.set_prescale"><code class="name flex">
<span>def <span class="ident">set_prescale</span></span>(<span>self, pwm_freq_hz: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the frequency of the output PWM signals</p>
<p>The max PWM frequency is 1526Hz
The min PWM frequency is 24Hz</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_prescale(self, pwm_freq_hz: float):
    &#39;&#39;&#39;Sets the frequency of the output PWM signals

        The max PWM frequency is 1526Hz
        The min PWM frequency is 24Hz

    &#39;&#39;&#39;
    # TODO - check if PCAs frequency is not out of range
    # TODO - what is the difrence between pwm_freq_hz and self.__frequency_hz  
    if pwm_freq_hz &gt;= 1500.0:
        raise ValueError(f&#34;[ERROR] The frequency of the PCA is too high. Frequency of {pwm_freq_hz} exceeds 1500Hz&#34;)
    
    if pwm_freq_hz &lt;= 24.0:
        raise ValueError(f&#34;[ERROR] The frequency of the PCA is too low. Frequency of {pwm_freq_hz} sub exceeds 24Hz&#34;)

    mode_1 = self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_MODE_1)
    sleep_state = mode_1 &amp; PCA_M1_SLEEP
    if not sleep_state:
        mode_1 |= PCA_M1_SLEEP
        self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)

    prescale_val = round((self.osc_frequency_Mhz * 1000000.0) / (4096.0 * pwm_freq_hz)) -1 
    print(&#34;prescale_val: &#34;, prescale_val)   
    self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_PRE_SCALE, prescale_val)
    
    if not sleep_state:
        mode_1 &amp;= ~PCA_M1_SLEEP
        self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)</code></pre>
</details>
</dd>
<dt id="PCA.PCA9685.set_sleep"><code class="name flex">
<span>def <span class="ident">set_sleep</span></span>(<span>self, sleep_on: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Puts the PCA into low power mode by turning off its oscillator
NOTE: outputs cannot be turned on or off</p>
<h2 id="parameters">Parameters</h2>
<pre><code>sleep_on : bool
    Sets the sleep state on or

    True -&gt; on
    False -&gt; off
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_sleep(self, sleep_on:bool = True):
    &#39;&#39;&#39;
    Puts the PCA into low power mode by turning off its oscillator
    NOTE: outputs cannot be turned on or off

    Parameters
    ----------

        sleep_on : bool
            Sets the sleep state on or 
        
            True -&gt; on
            False -&gt; off

    &#39;&#39;&#39;
    mode_1 = self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_MODE_1)
    sleep_state = mode_1 &amp; PCA_M1_SLEEP
    print(&#34;Sleep State: &#34;, sleep_state)
    if sleep_on and not sleep_state:
        mode_1 |= PCA_M1_SLEEP
        self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)
    elif not sleep_on and sleep_state:
        mode_1 &amp;= ~PCA_M1_SLEEP
        self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)</code></pre>
</details>
</dd>
<dt id="PCA.PCA9685.set_us"><code class="name flex">
<span>def <span class="ident">set_us</span></span>(<span>self, control_num: int, us: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_us(self, control_num:int, us:int):
    pwm_period_us = (1.0 / self.__measured_frequency) * 1_000_000.0
    us_on_ratio = us / pwm_period_us

    off_counts = round(us_on_ratio * 4096.0)
    on_counts = 0

    self.set_counts(control_num, on_counts, off_counts)</code></pre>
</details>
</dd>
<dt id="PCA.PCA9685.software_reset"><code class="name flex">
<span>def <span class="ident">software_reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows for the PCA to be reset to the inital 'power up state' without turning the PCA on and off</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def software_reset(self):
    &#39;&#39;&#39;
    Allows for the PCA to be reset to the inital &#39;power up state&#39; without turning the PCA on and off
    &#39;&#39;&#39;
    self.__i2c_bus.write_byte(0x00, 6)  </code></pre>
</details>
</dd>
<dt id="PCA.PCA9685.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#39;&#39;&#39;
    &#39;&#39;&#39;
    self.restart()
    time.sleep(0.01)  

    mode_1 = PCA_M1_AUTO_INC | 1
    self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)
    self.set_prescale(100)</code></pre>
</details>
</dd>
<dt id="PCA.PCA9685.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Closes the I2C connection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    &#39;&#39;&#39;Closes the I2C connection
    &#39;&#39;&#39;
    self.__i2c_bus.close()</code></pre>
</details>
</dd>
<dt id="PCA.PCA9685.use_extclk"><code class="name flex">
<span>def <span class="ident">use_extclk</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows for the use of an external clock on the PCA. <br>
This function will put the PCA to sleep to allow for external clocks to be used.</p>
<p>Inorder to rest the PCA to the default clock the PCA needs to be software_reset().
If this doesn't work try power cycling the PCA.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def use_extclk(self):
    &#39;&#39;&#39;
    Allows for the use of an external clock on the PCA.   
    This function will put the PCA to sleep to allow for external clocks to be used.

    Inorder to rest the PCA to the default clock the PCA needs to be software_reset().
    If this doesn&#39;t work try power cycling the PCA.

    &#39;&#39;&#39;
    mode_1 = self.__i2c_bus.read_byte_data(self.i2c_address, PCA_REG_MODE_1)
    extclk_state = mode_1 &amp; PCA_M1_EXTCLK
    if not extclk_state:
        sleep_state = mode_1 &amp; PCA_M1_SLEEP
        if not sleep_state:
            mode_1 |= PCA_M1_SLEEP
            self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)
        mode_1 |= PCA_M1_EXTCLK
        self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)
        if not sleep_state:
            mode_1 &amp;= ~PCA_M1_SLEEP
            self.__i2c_bus.write_byte_data(self.i2c_address, PCA_REG_MODE_1, mode_1)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PCA.PCA9685" href="#PCA.PCA9685">PCA9685</a></code></h4>
<ul class="">
<li><code><a title="PCA.PCA9685.get_bus" href="#PCA.PCA9685.get_bus">get_bus</a></code></li>
<li><code><a title="PCA.PCA9685.get_counts" href="#PCA.PCA9685.get_counts">get_counts</a></code></li>
<li><code><a title="PCA.PCA9685.get_mode_1" href="#PCA.PCA9685.get_mode_1">get_mode_1</a></code></li>
<li><code><a title="PCA.PCA9685.get_prescale" href="#PCA.PCA9685.get_prescale">get_prescale</a></code></li>
<li><code><a title="PCA.PCA9685.restart" href="#PCA.PCA9685.restart">restart</a></code></li>
<li><code><a title="PCA.PCA9685.set_counts" href="#PCA.PCA9685.set_counts">set_counts</a></code></li>
<li><code><a title="PCA.PCA9685.set_duty_cycle" href="#PCA.PCA9685.set_duty_cycle">set_duty_cycle</a></code></li>
<li><code><a title="PCA.PCA9685.set_duty_cycles" href="#PCA.PCA9685.set_duty_cycles">set_duty_cycles</a></code></li>
<li><code><a title="PCA.PCA9685.set_measured_frequency" href="#PCA.PCA9685.set_measured_frequency">set_measured_frequency</a></code></li>
<li><code><a title="PCA.PCA9685.set_prescale" href="#PCA.PCA9685.set_prescale">set_prescale</a></code></li>
<li><code><a title="PCA.PCA9685.set_sleep" href="#PCA.PCA9685.set_sleep">set_sleep</a></code></li>
<li><code><a title="PCA.PCA9685.set_us" href="#PCA.PCA9685.set_us">set_us</a></code></li>
<li><code><a title="PCA.PCA9685.software_reset" href="#PCA.PCA9685.software_reset">software_reset</a></code></li>
<li><code><a title="PCA.PCA9685.start" href="#PCA.PCA9685.start">start</a></code></li>
<li><code><a title="PCA.PCA9685.stop" href="#PCA.PCA9685.stop">stop</a></code></li>
<li><code><a title="PCA.PCA9685.use_extclk" href="#PCA.PCA9685.use_extclk">use_extclk</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>